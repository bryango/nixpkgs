{ lib
, buildPackages
}:

let
  # rudimentary support for cross-compiling
  # see: https://github.com/NixOS/nixpkgs/pull/279487#discussion_r1444449726
  inherit (buildPackages)
    mktemp
    rsync
    ;
in

rec {
  /* Prepare a derivation for local builds.
    *
    * This function prepares checkpoint builds by storing
    * the build output and the sources for cross checking.
    * The build output can be used later to allow checkpoint builds
    * by passing the derivation output to the `mkCheckpointBuild` function.
    *
    * To build a project with checkpoints, follow these steps:
    * - run `prepareCheckpointBuild` on the desired derivation, e.g.
    *     checkpointArtifacts = prepareCheckpointBuild virtualbox;
    * - change something you want in the sources of the package,
    *   e.g. using source override:
    *     changedVBox = pkgs.virtuabox.overrideAttrs (old: {
    *       src = path/to/vbox/sources;
    *     };
    * - use `mkCheckpointBuild changedVBox checkpointArtifacts`
    * - enjoy shorter build times
  */
  prepareCheckpointBuild = drv: drv.overrideAttrs (old: {
    outputs = [ "out" ];
    name = drv.name + "-checkpointArtifacts";
    # To determine differences between the state of the build directory
    # from an earlier build and a later one we store the state of the build
    # directory before build, but after patch phases.
    # This way, the same derivation can be used multiple times and only changes are detected.
    # Additionally, removed files are handled correctly in later builds.
    preBuild = (old.preBuild or "") + ''
      mkdir -p $out/sources
      shopt -s dotglob
      cp -r ./* $out/sources/
    '';

    # After the build, the build directory is copied again
    # to get the output files.
    # We copy the complete build folder, to take care of
    # build tools that build in the source directory, instead of
    # having a separate build directory such as the Linux kernel.
    installPhase = ''
      runHook preCheckpointInstall
      mkdir -p $out/outputs
      shopt -s dotglob
      cp -r ./* $out/outputs/
      runHook postCheckpointInstall
    '';
  });

  /* Build a derivation based on the checkpoint output generated by
    * the `prepareCheckpointBuild` function.
    *
    * Usage:
    * let
    *   checkpointArtifacts = prepareCheckpointBuild drv;
    * in mkCheckpointBuild drv checkpointArtifacts
  */
  mkCheckpointBuild = drv: checkpointArtifacts: drv.overrideAttrs (old: {

    postPatch = (old.postPatch or "") + ''
      ## handle binaries:
      newSourceBackup=$(${mktemp}/bin/mktemp -d)
      shopt -s dotglob
      cp -r ./* "$newSourceBackup"
    '';

    # The actual checkpoint build phase.
    # We compare the changed sources from a previous build with the current and create a patch.
    # Afterwards we clean the build directory and copy the previous output files (including the sources).
    # The source difference patch is then applied to get the latest changes again to allow short build times.
    preBuild = (old.preBuild or "") + ''
      set -e

      ## handle removed files:
      sourcePatch=$(${mktemp}/bin/mktemp)
      diff -ur ${checkpointArtifacts}/sources ./ > "$sourcePatch" || true

      ## clean up, do not panic when there is nothing left (expected)
      shopt -s dotglob
      rm -r ./* || true

      ## layer 0: artifacts
      ${rsync}/bin/rsync \
        --checksum --times --atimes --chmod=+w \
        -r ${checkpointArtifacts}/outputs/ .

      ## layer 1: handle removed files: patch source texts
      echo "$sourcePatch"
      patch -p 1 -i "$sourcePatch" || true
      ## ... do not panic when its unsuccessful (remedied immediately)

      ## layer 2: handle binaries: overlay the new source
      ${rsync}/bin/rsync \
        --checksum --times --atimes --chmod=+w \
        -r "$newSourceBackup"/ .

      ## clean up
      rm "$sourcePatch"
      rm -rf "$newSourceBackup"
    '';
  });

  mkCheckpointedBuild = lib.warn
    "`mkCheckpointedBuild` is deprecated; use `mkCheckpointBuild` instead."
    mkCheckpointBuild;
}
